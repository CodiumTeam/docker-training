# Exercise 2: Basic commands

## Exercise 2.1: Running a command inside an ephemeral container

A container is designed to execute a single binary. It is possible to change the command that will get executed by passing parameters to the run docker command.

- Return the working directory inside an alpine container.

  ```bash
  docker run alpine pwd
  ```

- Try to run several commands inside the container (it will fail):

  ```bash
  docker run alpine pwd; ls
  ```

  The reason why it fails is that Docker only takes as a command what you wrote up to the semicolon. The `ls` will be a command in your own local machine, it is not passed to the alpine container.

- In order to run several commands in a container, you can pass them after `sh -c` (it's a common way of running a command with `sh`, very popular in Docker containers).

  ```bash
  docker run alpine sh -c 'pwd; ls'
  ```

## Exercise 2.2: check containers are ephemeral

The filesystem inside a container is ephemeral.

1. Run a new container and put it to sleep (we just want it to exist for a while)
   ```bash
   docker run --rm alpine sh -c 'touch hola.txt && ls'
   ```
2. Check that the container appears with the right name and command being executed
   ```bash
   docker run --rm alpine sh -c 'ls'
   ```

## Exercise 2.3: practice with run, logs, ps

TODO: Los contenedores a veces pueden pararse por algún fallo. En este ejercicio simularemos el fallo con el stop para a continuación blablabla.

1. Vemos que no hay nada
   ```bash
   docker ps
   ```
2. Vemos que aparecen los contenedores ejecutados antes blablab
   ```bash
   docker ps -a
   ```
   Fijarse en que tienen un nombre aleatorio
3. Borrar uno solo (seleccionar el nombre blabla)
   ```bash
   docker rm [container-name]
   ```
   Como alternativa, podríamos haber arrancado el contenedor con the flag `--rm`, the container will be removed after running the desired command (you won't see it with `docker ps -a`).
4. Create a MongoDB container in detached mode, with name `my-mongo`:
   ```bash
   docker run -d --name my-mongo mongo
   ```
5. Show the running container. Remark the info shown.
   ```bash
   docker ps
   ```
6. Show the logs generated for the running Mongo container
   ```bash
   docker logs my-mongo
   ```
7. xxxx
   ```bash
   docker run --name my-hello-world -d hello-world
   ```
8. Now you should see both Mongo containers running
   ```bash
   docker logs my-hello-world
   ```
9. Show only the container ids (`quiet` mode)
   ```bash
   docker ps -aq
   ```
10. Finally, you can delete all the existing containers, no matter their status
    ```bash
    docker ps -aq | xargs docker rm -f
    ```
    Windows version:
    ```bash
    docker ps -aq | % {docker rm -f $_}
    ```
11. Mostrar que ha borrado todos, no queda nada
    ```bash
    docker ps -a
    ```

## Exercise 2.4: Run commands in an already running container

TODO: poner en contexto el ejercicio. Vamos a arrancar un contenedor de una base de datos Mongo en segundo plano e interactuaremos usando su CLI, que es el binario "mongo".

1. Run a new Mongo container in detached mode
   ```bash
   docker run -d --rm --name my-mongo mongo
   ```
2. Execute the command `mongo --help` on the running container
   ```bash
   docker exec my-mongo mongo --help
   ```
3. Insert a new document inside a new `users` collection
   ```bash
   docker exec my-mongo mongo --eval 'db.users.insertOne({name: "jonas"})'
   ```
4. Show all the existing documents inside the `users` collection
   ```bash
   docker exec my-mongo mongo --eval 'db.users.find()'
   ```
5. Connect to the Mongo container in an interactive way
   ```bash
   docker exec -ti my-mongo mongo
   ```
   5.1. Inside the container, show all the existing documents
   ```bash
   db.users.find()
   ```
   5.2. Exit the container
   ```bash
   exit
   ```
6. Show the last 3 logs generated by the Mongo container
   ```bash
   docker logs -n 3 my-mongo
   ```
7. Stop the running container
   ```bash
   docker stop my-mongo
   ```

## Bonus track

### Filter the existing containers

- `docker ps -a`: to see all containers in any state (not only running)
- `docker ps --filter "name=mongo"`: filter and show only the containers which name contains the word _mongo_
- `docker ps -a --filter 'exited=0'`: show only the containers which exit code was `0`.
- `docker ps --filter status=running`: show only the containers which are in a specific status (e.g. running, created, exited, restarting, etc.).

### Stopping containers

- Another way of stopping all the containers: `docker stop $(docker ps -qa)`
- Remove all stopped containers: `docker rm $(docker ps --filter status=exited -q)`

### Play with the logs command

- Run a new Mongo container in detached mode: `docker run -d --name my-mongo mongo`
- Show the current logs: `docker logs my-mongo`
- Follow the logs (it will be shown in real time): `docker logs my-mongo -f`
  - You can exit just typing Control+C
- Show the logs with a timestamp at the beginning of each line: `docker logs my-mongo --timestamps`
- Show the logs generated during the last 5 minutes: `docker logs --since 5m my-mongo`
- Show the last 10 lines of logs: `docker logs --tail 10 my-mongo`
